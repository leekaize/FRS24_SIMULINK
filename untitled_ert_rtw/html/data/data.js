var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"untitled","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\kzlee\\Desktop\\FRS24\\FRS24_SIMULINK\\untitled_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * ert_main.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"untitled\".\r\n *\r\n * Model version              : 1.0\r\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\r\n * C source code generated on : Wed Aug 28 15:15:29 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include \"untitled.h\"\r\n#include \"untitled_private.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"limits.h\"\r\n#include \"MW_ArduinoHWInit.h\"\r\n#include \"mw_freertos.h\"\r\n#define UNUSED(x)                      x = x\r\n#define NAMELEN                        16\r\n\r\n/* Function prototype declaration*/\r\nvoid exitFcn(int sig);\r\nvoid *terminateTask(void *arg);\r\nvoid *baseRateTask(void *arg);\r\nvoid *subrateTask(void *arg);\r\nvolatile boolean_T stopRequested = false;\r\nvolatile boolean_T runModel = true;\r\nSemaphoreHandle_t stopSem;\r\nSemaphoreHandle_t baserateTaskSem;\r\nmw_thread_t schedulerThread;\r\nmw_thread_t baseRateThread;\r\nvoid *threadJoinStatus;\r\nint terminatingmodel = 0;\r\nvoid *baseRateTask(void *arg)\r\n{\r\n  runModel = (rtmGetErrorStatus(untitled_M) == (NULL));\r\n  while (runModel) {\r\n    mw_osSemaphoreWaitEver(&baserateTaskSem);\r\n    untitled_step();\r\n\r\n    /* Get model outputs here */\r\n    stopRequested = !((rtmGetErrorStatus(untitled_M) == (NULL)));\r\n    runModel = !stopRequested;\r\n  }\r\n\r\n  runModel = 0;\r\n  terminateTask(arg);\r\n  mw_osThreadExit((void *)0);\r\n  return NULL;\r\n}\r\n\r\nvoid exitFcn(int sig)\r\n{\r\n  UNUSED(sig);\r\n  rtmSetErrorStatus(untitled_M, \"stopping the model\");\r\n}\r\n\r\nvoid *terminateTask(void *arg)\r\n{\r\n  UNUSED(arg);\r\n  terminatingmodel = 1;\r\n\r\n  {\r\n    runModel = 0;\r\n  }\r\n\r\n  /* Terminate model */\r\n  untitled_terminate();\r\n  mw_osSemaphoreRelease(&stopSem);\r\n  return NULL;\r\n}\r\n\r\nint app_main(int argc, char **argv)\r\n{\r\n  init();\r\n  MW_Arduino_Init();\r\n  rtmSetErrorStatus(untitled_M, 0);\r\n\r\n  /* Initialize model */\r\n  untitled_initialize();\r\n\r\n  /* Call RTOS Initialization function */\r\n  mw_RTOSInit(0.1, 0);\r\n\r\n  /* Wait for stop semaphore */\r\n  mw_osSemaphoreWaitEver(&stopSem);\r\n\r\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\r\n\r\n  {\r\n    int i;\r\n    for (i=0; i < MW_NUMBER_TIMER_DRIVEN_TASKS; i++) {\r\n      CHECK_STATUS(mw_osSemaphoreDelete(&timerTaskSem[i]), 0,\r\n                   \"mw_osSemaphoreDelete\");\r\n    }\r\n  }\r\n\r\n#endif\r\n\r\n  return 0;\r\n}\r\n"},{"name":"untitled.c","type":"source","group":"model","path":"C:\\Users\\kzlee\\Desktop\\FRS24\\FRS24_SIMULINK\\untitled_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * untitled.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"untitled\".\r\n *\r\n * Model version              : 1.0\r\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\r\n * C source code generated on : Wed Aug 28 15:15:29 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"untitled.h\"\r\n#include <math.h>\r\n#include \"untitled_private.h\"\r\n#include \"rtwtypes.h\"\r\n#include <string.h>\r\n\r\n/* Block states (default storage) */\r\nDW_untitled_T untitled_DW;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_untitled_T untitled_M_;\r\nRT_MODEL_untitled_T *const untitled_M = &untitled_M_;\r\nreal_T rt_roundd_snf(real_T u)\r\n{\r\n  real_T y;\r\n  if (fabs(u) < 4.503599627370496E+15) {\r\n    if (u >= 0.5) {\r\n      y = floor(u + 0.5);\r\n    } else if (u > -0.5) {\r\n      y = u * 0.0;\r\n    } else {\r\n      y = ceil(u - 0.5);\r\n    }\r\n  } else {\r\n    y = u;\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/* Model step function */\r\nvoid untitled_step(void)\r\n{\r\n  real_T tmp;\r\n  uint8_T tmp_0;\r\n\r\n  /* Switch: '<Root>/Switch' incorporates:\r\n   *  Constant: '<Root>/OFF'\r\n   *  Constant: '<Root>/ON'\r\n   *  Constant: '<S1>/Constant'\r\n   *  RelationalOperator: '<S1>/Compare'\r\n   *  Sin: '<Root>/Sine Wave'\r\n   */\r\n  if (sin(((real_T)untitled_DW.counter + untitled_P.SineWave_Offset) * 2.0 *\r\n          3.1415926535897931 / untitled_P.SineWave_NumSamp) *\r\n      untitled_P.SineWave_Amp + untitled_P.SineWave_Bias >=\r\n      untitled_P.CompareToConstant_const) {\r\n    tmp = untitled_P.ON_Value;\r\n  } else {\r\n    tmp = untitled_P.OFF_Value;\r\n  }\r\n\r\n  /* MATLABSystem: '<Root>/Digital Output' incorporates:\r\n   *  Switch: '<Root>/Switch'\r\n   */\r\n  tmp = rt_roundd_snf(tmp);\r\n  if (tmp < 256.0) {\r\n    if (tmp >= 0.0) {\r\n      tmp_0 = (uint8_T)tmp;\r\n    } else {\r\n      tmp_0 = 0U;\r\n    }\r\n  } else {\r\n    tmp_0 = MAX_uint8_T;\r\n  }\r\n\r\n  writeDigitalPin(2, tmp_0);\r\n\r\n  /* End of MATLABSystem: '<Root>/Digital Output' */\r\n\r\n  /* Update for Sin: '<Root>/Sine Wave' */\r\n  untitled_DW.counter++;\r\n  if (untitled_DW.counter == untitled_P.SineWave_NumSamp) {\r\n    untitled_DW.counter = 0;\r\n  }\r\n\r\n  /* End of Update for Sin: '<Root>/Sine Wave' */\r\n}\r\n\r\n/* Model initialize function */\r\nvoid untitled_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize error status */\r\n  rtmSetErrorStatus(untitled_M, (NULL));\r\n\r\n  /* states (dwork) */\r\n  (void) memset((void *)&untitled_DW, 0,\r\n                sizeof(DW_untitled_T));\r\n\r\n  /* Start for MATLABSystem: '<Root>/Digital Output' */\r\n  untitled_DW.obj.matlabCodegenIsDeleted = false;\r\n  untitled_DW.obj.isInitialized = 1;\r\n  digitalIOSetup(2, 1);\r\n  untitled_DW.obj.isSetupComplete = true;\r\n\r\n  /* InitializeConditions for Sin: '<Root>/Sine Wave' */\r\n  untitled_DW.counter = 0;\r\n}\r\n\r\n/* Model terminate function */\r\nvoid untitled_terminate(void)\r\n{\r\n  /* Terminate for MATLABSystem: '<Root>/Digital Output' */\r\n  if (!untitled_DW.obj.matlabCodegenIsDeleted) {\r\n    untitled_DW.obj.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<Root>/Digital Output' */\r\n}\r\n"},{"name":"untitled.h","type":"header","group":"model","path":"C:\\Users\\kzlee\\Desktop\\FRS24\\FRS24_SIMULINK\\untitled_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * untitled.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"untitled\".\r\n *\r\n * Model version              : 1.0\r\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\r\n * C source code generated on : Wed Aug 28 15:15:29 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef untitled_h_\r\n#define untitled_h_\r\n#ifndef untitled_COMMON_INCLUDES_\r\n#define untitled_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#include \"MW_arduino_digitalio.h\"\r\n#endif                                 /* untitled_COMMON_INCLUDES_ */\r\n\r\n#include \"untitled_types.h\"\r\n#include <stddef.h>\r\n#include <string.h>\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  codertarget_arduinobase_block_T obj; /* '<Root>/Digital Output' */\r\n  int32_T counter;                     /* '<Root>/Sine Wave' */\r\n} DW_untitled_T;\r\n\r\n/* Parameters (default storage) */\r\nstruct P_untitled_T_ {\r\n  real_T CompareToConstant_const;     /* Mask Parameter: CompareToConstant_const\r\n                                       * Referenced by: '<S1>/Constant'\r\n                                       */\r\n  real_T ON_Value;                     /* Expression: 1\r\n                                        * Referenced by: '<Root>/ON'\r\n                                        */\r\n  real_T OFF_Value;                    /* Expression: 0\r\n                                        * Referenced by: '<Root>/OFF'\r\n                                        */\r\n  real_T SineWave_Amp;                 /* Expression: 5\r\n                                        * Referenced by: '<Root>/Sine Wave'\r\n                                        */\r\n  real_T SineWave_Bias;                /* Expression: 0\r\n                                        * Referenced by: '<Root>/Sine Wave'\r\n                                        */\r\n  real_T SineWave_NumSamp;             /* Expression: 10\r\n                                        * Referenced by: '<Root>/Sine Wave'\r\n                                        */\r\n  real_T SineWave_Offset;              /* Expression: 0\r\n                                        * Referenced by: '<Root>/Sine Wave'\r\n                                        */\r\n};\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_untitled_T {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern P_untitled_T untitled_P;\r\n\r\n/* Block states (default storage) */\r\nextern DW_untitled_T untitled_DW;\r\n\r\n/* Model entry point functions */\r\nextern void untitled_initialize(void);\r\nextern void untitled_step(void);\r\nextern void untitled_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_untitled_T *const untitled_M;\r\nextern volatile boolean_T stopRequested;\r\nextern volatile boolean_T runModel;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<Root>/Scope' : Unused code path elimination\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'untitled'\r\n * '<S1>'   : 'untitled/Compare To Constant'\r\n */\r\n#endif                                 /* untitled_h_ */\r\n"},{"name":"untitled_private.h","type":"header","group":"model","path":"C:\\Users\\kzlee\\Desktop\\FRS24\\FRS24_SIMULINK\\untitled_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * untitled_private.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"untitled\".\r\n *\r\n * Model version              : 1.0\r\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\r\n * C source code generated on : Wed Aug 28 15:15:29 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef untitled_private_h_\r\n#define untitled_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"untitled_types.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n\r\nextern real_T rt_roundd_snf(real_T u);\r\n\r\n#endif                                 /* untitled_private_h_ */\r\n"},{"name":"untitled_types.h","type":"header","group":"model","path":"C:\\Users\\kzlee\\Desktop\\FRS24\\FRS24_SIMULINK\\untitled_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * untitled_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"untitled\".\r\n *\r\n * Model version              : 1.0\r\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\r\n * C source code generated on : Wed Aug 28 15:15:29 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef untitled_types_h_\r\n#define untitled_types_h_\r\n#include \"rtwtypes.h\"\r\n#ifndef struct_tag_9aqKbsbsI7JI0RwgnVwU0C\r\n#define struct_tag_9aqKbsbsI7JI0RwgnVwU0C\r\n\r\nstruct tag_9aqKbsbsI7JI0RwgnVwU0C\r\n{\r\n  int32_T __dummy;\r\n};\r\n\r\n#endif                                 /* struct_tag_9aqKbsbsI7JI0RwgnVwU0C */\r\n\r\n#ifndef typedef_b_arduinodriver_ArduinoDigita_T\r\n#define typedef_b_arduinodriver_ArduinoDigita_T\r\n\r\ntypedef struct tag_9aqKbsbsI7JI0RwgnVwU0C b_arduinodriver_ArduinoDigita_T;\r\n\r\n#endif                             /* typedef_b_arduinodriver_ArduinoDigita_T */\r\n\r\n#ifndef struct_tag_qrLkTWTW64zZK0sqwALTyG\r\n#define struct_tag_qrLkTWTW64zZK0sqwALTyG\r\n\r\nstruct tag_qrLkTWTW64zZK0sqwALTyG\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  b_arduinodriver_ArduinoDigita_T DigitalIODriverObj;\r\n};\r\n\r\n#endif                                 /* struct_tag_qrLkTWTW64zZK0sqwALTyG */\r\n\r\n#ifndef typedef_codertarget_arduinobase_block_T\r\n#define typedef_codertarget_arduinobase_block_T\r\n\r\ntypedef struct tag_qrLkTWTW64zZK0sqwALTyG codertarget_arduinobase_block_T;\r\n\r\n#endif                             /* typedef_codertarget_arduinobase_block_T */\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_untitled_T_ P_untitled_T;\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_untitled_T RT_MODEL_untitled_T;\r\n\r\n#endif                                 /* untitled_types_h_ */\r\n"},{"name":"untitled_data.c","type":"source","group":"data","path":"C:\\Users\\kzlee\\Desktop\\FRS24\\FRS24_SIMULINK\\untitled_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * untitled_data.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"untitled\".\r\n *\r\n * Model version              : 1.0\r\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\r\n * C source code generated on : Wed Aug 28 15:15:29 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"untitled.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP_untitled_T untitled_P = {\r\n  /* Mask Parameter: CompareToConstant_const\r\n   * Referenced by: '<S1>/Constant'\r\n   */\r\n  3.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<Root>/ON'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/OFF'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 5\r\n   * Referenced by: '<Root>/Sine Wave'\r\n   */\r\n  5.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Sine Wave'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 10\r\n   * Referenced by: '<Root>/Sine Wave'\r\n   */\r\n  10.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Sine Wave'\r\n   */\r\n  0.0\r\n};\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\kzlee\\Desktop\\FRS24\\FRS24_SIMULINK\\untitled_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"untitled\".\r\n *\r\n * Model version              : 1.0\r\n * Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\r\n * C source code generated on : Wed Aug 28 15:15:29 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: ARM Compatible->ARM Cortex\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\kzlee\\Desktop\\FRS24\\FRS24_SIMULINK\\untitled_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * rtmodel.h\r\n *\r\n * Code generation for Simulink model \"untitled\".\r\n *\r\n * Simulink Coder version                : 24.1 (R2024a) 19-Nov-2023\r\n * C source code generated on : Wed Aug 28 15:15:29 2024\r\n *\r\n * Note that the generated code is not dependent on this header file.\r\n * The file is used in cojuction with the automatic build procedure.\r\n * It is included by the sample main executable harness\r\n * MATLAB/rtw/c/src/common/rt_main.c.\r\n *\r\n */\r\n\r\n#ifndef rtmodel_h_\r\n#define rtmodel_h_\r\n#include \"untitled.h\"\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 /* rtmodel_h_ */\r\n"},{"name":"MW_ArduinoHWInit.cpp","type":"source","group":"legacy","path":"C:\\Users\\kzlee\\Desktop\\FRS24\\FRS24_SIMULINK\\untitled_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024a\\toolbox\\target\\supportpackages\\arduinotarget\\src","tag":"","groupDisplay":"Other files","code":"/* Arduino AVR Bareboard scheduler\n*\n* Copyright 2014-2023 The MathWorks, Inc.\n*/\n\n#include \"Arduino.h\"\n#include \"io_wrappers.h\"\n#if defined(ARDUINO_ARM_CORTEX_M0_PLUS)\n#include \"arduinoARM_M0plusScheduler.h\"\n#elif defined(ARDUINO_ARM_CORTEX_M3)\n#include \"arduinoARMScheduler.h\"\n#include \"watchdog.h\"\n#else\n#include \"arduinoAVRScheduler.h\"\n#endif\n\n#if defined(ESP_PLATFORM)\n#include \"esp_wpa2.h\" //wpa2 library for connections to Enterprise networks\n#endif\n\n#ifdef _RTT_NUMI2C_\n#include \"MW_arduinoI2C.h\"\n#endif\n\n#if defined(ARDUINO_ARDUINO_NANO33BLE)\n#include \"MW_PWM_NANO33BLE.h\"\n#endif\n\n#if (defined(MW_ARDUINO_OV2640CSPIN)) || (defined(_RTT_SPI_SSPIN_)) || (defined(_RTT_DUE_SPI_SSPIN4_)) || (defined(_RTT_DUE_SPI_SSPIN10_)) || (defined(_RTT_DUE_SPI_SSPIN52_))\n#include \"MW_SPIwriteRead.h\"\n#endif\n\n#if (defined(_RTT_RS485_INUSE_))\n#include \"ArduinoRS485.h\"\n#endif\n\n#if (defined(_RTT_MODBUS_MASTER_)) || (defined(_RTT_MODBUS_SLAVE_))\n#include \"ArduinoModbus.h\"\n#endif\n\n#ifdef NANO_MOTOR_CARRIER\n#include <Wire.h>\n#define PMIC_ADDRESS  0x6B\n#define PMIC_REG00    0x00\n#define PMIC_REG01    0x01\n#define PMIC_REG02    0x02\n#define PMIC_REG04    0x04\n#define PMIC_REG05    0x05\nvoid MW_EnableNanoCarrierBatteryCharging(void);\n#endif\n\n// Wifi init routines\n#include <inttypes.h>\n#if (defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)) || (defined(_RTT_WIFI_UDP_) && (_RTT_WIFI_UDP_ != 0)) || (defined(_RTT_WIFI_TCP_) && (_RTT_WIFI_TCP_ != 0))|| defined(_RTT_THINGSPEAK_WIFI_) || defined(_RTT_WEBSOCKET_PORT_) || defined(_RTT_MQTT_WIFI_) || defined(_RTT_HTTP_CLIENT_)\n#if defined(ARDUINO_WIFI_LIB_101)\n#include <WiFi101.h>\n#elif defined(ARDUINO_WIFI_LIB_NINA)\n#include <WiFiNINA.h>\n#else\n#include <WiFi.h>\n#endif\n#include <SPI.h>\n\n/*#define that helps to stringify build flags\n//Double evaluation is needed so that the double quotes can be derived out\n//of the build flag and can be assigned to a character array */\n#define RTT_StringifyBuildFlag(x) RTT_StringParamExpanded(x)\n#define RTT_StringParamExpanded(x)  #x\n\n#if (_RTT_DISABLE_Wifi_DHCP_ == 1)\nIPAddress wifiLocalIpAddress(_RTT_WIFI_Local_IP1, _RTT_WIFI_Local_IP2, _RTT_WIFI_Local_IP3, _RTT_WIFI_Local_IP4);\n#endif\n\n#if (_RTT_DISABLE_Wifi_DHCP_ == 2)\nIPAddress wifiLocalIpAddress(_RTT_WIFI_Local_IP1, _RTT_WIFI_Local_IP2, _RTT_WIFI_Local_IP3, _RTT_WIFI_Local_IP4);\nIPAddress wifiGatewayAddress(_RTT_WIFI_Gateway_IP1, _RTT_WIFI_Gateway_IP2, _RTT_WIFI_Gateway_IP3, _RTT_WIFI_Gateway_IP4);\nIPAddress wifiSubnetMask(_RTT_WIFI_Subnet_IP1, _RTT_WIFI_Subnet_IP2, _RTT_WIFI_Subnet_IP3, _RTT_WIFI_Subnet_IP4);\nIPAddress wifiDNSAddress(_RTT_WIFI_DNS_IP1, _RTT_WIFI_DNS_IP2, _RTT_WIFI_DNS_IP3, _RTT_WIFI_DNS_IP4);\n#endif\n\n#ifdef ESP_PLATFORM\nIPAddress wifigateway(_RTT_WIFI_Local_IP1, _RTT_WIFI_Local_IP2, _RTT_WIFI_Local_IP3, uint8_t(1));\nIPAddress subnet(uint8_t(255),uint8_t(255),uint8_t(255),uint8_t(0));\nIPAddress dns1 = (uint32_t)0x00000000;\nIPAddress dns2 = (uint32_t)0x00000000;\n#endif\n\nchar ssid[] = RTT_StringifyBuildFlag(_RTT_WIFI_SSID);\nint configureSuccess = WL_IDLE_STATUS;\nint trialcount;\n\n#ifdef _RTT_WIFI_WEP\nchar key[] = RTT_StringifyBuildFlag(_RTT_WIFI_KEY);\nint keyIndex = _RTT_WIFI_KEY_INDEX;\n#endif //_RTT_WIFI_WEP\n\n#ifdef _RTT_WIFI_WPA\nchar wpapass[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA_PASSWORD);\n#endif //_RTT_WIFI_WPA\n\n#ifdef _RTT_WIFI_WPA2_ENTERPRISE\nchar wpa2username[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA2_USERNAME);\nchar wpa2password[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA2_PASSWORD);\n#endif //_RTT_WIFI_WPA2_ENTERPRISE\n#endif //(defined(_RTT_THINGSPEAK_WIFI_) || (_RTT_WIFI_TCP_ !=0) || defined(_RTT_WEBSOCKET_PORT_))\n\n#include \"MW_ArduinoHWInit.h\"\n#ifdef _MW_DASHBOARD_BLOCK_PRESENT_\n#include \"MW_graphicPrimitive.h\"\n#endif\n\n\n\nvoid MW_Modbus_Slave_Poll(void)\n{\n    #if defined(_RTT_MODBUS_SLAVE_)\n    ModbusRTUServer.poll();\n    #endif\n}\n\nvoid MW_ArduinoNano33BLESenseInit(void)\n{\n    #if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    initVariant();\n    #if defined(SERIAL_CDC)\n    PluggableUSBD().begin();\n    SerialUSB.begin(115200);\n    #endif\n    #if defined(_RTT_PWM_NANO33BLE_INUSE)\n    MW_NANO33BLE_PWM_Setup();\n    #endif\n    #endif\n}\n\nvoid MW_Arduino_Init(void)\n{\n    //Hardware specific init for Arduino nano 33 ble sense\n    #if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    MW_ArduinoNano33BLESenseInit();\n    #endif\n    //Disable watchdog for Arduino Due. watchdog\n    #if (defined(_ROTH_DUE_))\n    watchdogDisable();\n    #endif\n    //Disable watchdog for ESP32\n    #if (defined(ESP_PLATFORM))\n    initArduino();\n    disableCore0WDT();\n    #endif\n\n    /*\n    * Initialize Serial Peripheral\n    */\n    // Always Initialize Serial0\n    #if(defined(ESP_PLATFORM))\n    #else\n    Serial_begin(0, _RTT_BAUDRATE_SERIAL0_, _RTT_CONFIG_SERIAL0_);\n    #endif\n\n    /* Overrun Detection Initialization */\n    #ifdef _RTT_OVERRUN_DIGITAL_PIN_\n    pinMode(_RTT_OVERRUN_DIGITAL_PIN_, OUTPUT);\n\n    /* Init the overrun detection pin to zero or else the Pin is always in a\n    * high/tristate giving the user a wrong indication of overrun conditions */\n    digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, LOW);\n    #endif\n\n    /*\n    * Initialize Analog Reference Voltage\n    * Default - Due\n    * Default, Internal 1.1, Internal 2.56, External -  Mega 2560, Mega ADK\n    * Default, Internal, External - Other Arduino targets\n    */\n    #if (defined(_ROTH_MEGA2560_))\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(INTERNAL1V1);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(INTERNAL2V56);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 3))\n    analogReference(EXTERNAL);\n    #endif\n    #elif defined(ARDUINO_ARM_CORTEX_M0_PLUS)\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(AR_INTERNAL1V0);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(AR_INTERNAL1V65);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 3))\n    analogReference(AR_INTERNAL2V23);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 4))\n    analogReference(AR_EXTERNAL);\n    #endif\n    #else\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(INTERNAL);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(EXTERNAL);\n    #endif\n    #endif\n\n    /*\n    * Initialize SPI bus\n    */\n    //_RTT_SPI_SSPIN_ definition is applicable for all boards excluding Due\n    #if (defined(_RTT_SPI_SSPIN_)) || (defined(MW_ARDUINO_OV2640CSPIN))\n    MW_SPIwriteReadSetup();\n    #endif\n\n    //Initialize Modbus\n    int modStatus;\n    #if defined(_RTT_MODBUS_MASTER_)\n    modStatus = ModbusRTUClient.begin(_RTT_RS485_BAUD_, _RTT_RS485_CONFIG_);\n    ModbusRTUClient.setTimeout(_RTT_MODBUS_MASTERTIMEOUT_/1000);\n    #endif\n\n    #if defined(_RTT_MODBUS_SLAVE_)\n    modStatus = ModbusRTUServer.begin(_RTT_MODBUS_SLAVEID_, _RTT_RS485_BAUD_, _RTT_RS485_CONFIG_);\n    #if defined(_RTT_MODBUS_CONFIGCOIL_)\n    ModbusRTUServer.configureCoils(_RTT_MODBUS_COILADDR_,_RTT_MODBUS_COILNUM_);\n    #endif\n    #if defined(_RTT_MODBUS_CONFIGINPUT_)\n    ModbusRTUServer.configureDiscreteInputs(_RTT_MODBUS_INPUPTADDR_,_RTT_MODBUS_INPUTNUM_);\n    #endif\n    #if defined(_RTT_MODBUS_CONFIGHOLDINGREG_)\n    ModbusRTUServer.configureHoldingRegisters(_RTT_MODBUS_HOLDINGREGADDR_,_RTT_MODBUS_HOLDINGREGNUM_);\n    #endif\n    #if defined(_RTT_MODBUS_CONFIGINPUTREG_)\n    ModbusRTUServer.configureInputRegisters(_RTT_MODBUS_INPUTREGADDR_,_RTT_MODBUS_INPUTREGNUM_);\n    #endif\n    #endif\n\n    /*\n    * Initialize wifi\n    */\n    #if (defined(_RTT_WIFI_UDP_) && (_RTT_WIFI_UDP_ != 0)) || (defined(_RTT_WIFI_TCP_) && (_RTT_WIFI_TCP_ != 0))|| defined(_RTT_THINGSPEAK_WIFI_) || defined(_RTT_WEBSOCKET_PORT_) || defined(_RTT_MQTT_WIFI_) || defined(_RTT_HTTP_CLIENT_)\n    /* Begin WiFi*/\n    while(configureSuccess!=WL_CONNECTED)\n    {\n        #if (defined(_RTT_DISABLE_Wifi_DHCP_) && (_RTT_DISABLE_Wifi_DHCP_ !=0))\n            #ifdef ESP_PLATFORM\n                #if (_RTT_DISABLE_Wifi_DHCP_ == 1)\n                WiFi.config(wifiLocalIpAddress,wifigateway, subnet, dns1, dns2);\n                #else\n                WiFi.config(wifiLocalIpAddress, wifiGatewayAddress, wifiSubnetMask, wifiDNSAddress);\n                #endif\n            #elif (_RTT_DISABLE_Wifi_DHCP_ == 1)\n            WiFi.config(wifiLocalIpAddress);\n            #else\n            WiFi.config(wifiLocalIpAddress, wifiDNSAddress, wifiGatewayAddress, wifiSubnetMask);\n            #endif\n        #endif\n\n        #ifdef _RTT_WIFI_WEP\n        configureSuccess=WiFi.begin(ssid,keyIndex,key);\n        #endif //_RTT_WIFI_WEP\n\n        #ifdef _RTT_WIFI_WPA\n        configureSuccess=WiFi.begin(ssid,wpapass);\n        #endif //_RTT_WIFI_WPA\n\n        #ifdef _RTT_WIFI_WPA2_ENTERPRISE\n        #if defined(ESP_PLATFORM)\n        WiFi.disconnect(true);  //disconnect form wifi to set new wifi connection\n        WiFi.mode(WIFI_STA); //init wifi mode\n        configureSuccess = WiFi.begin(ssid, WPA2_AUTH_PEAP, wpa2username, wpa2username, wpa2password); //connect to wifi\n        #elif defined(ARDUINO_WIFI_LIB_NINA)\n        configureSuccess=WiFi.beginEnterprise(ssid,wpa2username,wpa2password);\n        #endif\n        #endif //_RTT_WIFI_WPA2_ENTERPRISE\n\n        #ifdef _RTT_WIFI_NONE\n        configureSuccess=WiFi.begin(ssid);\n        #endif //_RTT_WIFI_NONE\n\n        #if (defined(ESP_PLATFORM))\n        while (WiFi.status() != WL_CONNECTED) {\n            delay(500);\n        }\n        configureSuccess=WL_CONNECTED;\n        #else\n        //Wait for 10 seconds for Wifi connection to happen\n        unsigned long startMillis  = millis();\n        while(millis()- startMillis < 1000)\n        {\n        };\n        #endif\n    }\n\n    /* Wait for Serial0 to be up*/\n    for(trialcount=0;trialcount<5;trialcount++)\n    {\n        if(Serial)\n        {\n            break;\n        }else\n        {\n            unsigned long startMillis  = millis();\n            while(millis()- startMillis < 1000)\n            {\n            };\n        }\n    }\n\n    #if (!(defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)))\n    if (configureSuccess==WL_CONNECTED)\n    {\n        // If the Configuration is successful, relay back the assigned IP address.\n        #if(defined(ESP_PLATFORM))\n        Serial_begin(0, _RTT_BAUDRATE_SERIAL0_, _RTT_CONFIG_SERIAL0_);\n        #endif\n        IPAddress ip = WiFi.localIP();\n        //Adding a precautionary check using a Serial command so as to print the IP address so that it is available at least 6 times \n        //and the chances of it not being assigned to Target are minimised.\n        for(int ipSendcounter=0; ipSendcounter<6; ipSendcounter++)\n        {\n            Serial.print(\"<<< IP address :\");\n            Serial.print(ip);\n            Serial.println(\" >>>\");\n            delay(500);\n        }\n    }\n    else\n    {\n        // If the Configuration failed,relay back the error message.\n        Serial.println(\"<<< IP address :Failed to configure. >>>\");\n    }\n    #endif //(!(defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)))\n\n    #endif /*Initialize wifi*/\n    #ifdef NANO_MOTOR_CARRIER\n    MW_EnableNanoCarrierBatteryCharging();\n    #endif\n    #ifdef _MW_DASHBOARD_BLOCK_PRESENT_\n    MW_initScreen();\n    #endif\n\n    #if defined(ARDUINO_ARCH_SAMD) && defined(MW_SAMD_EVSYS_ENABLE)\n    PM->APBCMASK.reg |= PM_APBCMASK_EVSYS;                                              // Switch on the event system peripheral\n    #if defined(MW_SAMD_EVSYS_CH0)\n    EVSYS->USER.reg = EVSYS_USER_CHANNEL(1) |                                           // Attach the event user (receiver) to channel 0 (n + 1)\n        EVSYS_USER_USER(EVSYS_CH0_USER_EVENT);                            // Set the event user (receiver) as EVSYS_CH1_USER_EVENT\n    EVSYS->CHANNEL.reg = EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT |                           // No event edge detection\n        EVSYS_CHANNEL_PATH_ASYNCHRONOUS |                              // Set event path as asynchronous\n        EVSYS_CHANNEL_EVGEN(EVSYS_CH0_GEN_EVENT) |                     // Set event generator (sender) as EVSYS_CH1_GEN_EVENT\n        EVSYS_CHANNEL_CHANNEL(0);                                      // Attach the generator (sender) to channel 0\n    EVSYS_CH0_USER->EVCTRL.reg |= EVSYS_CH0_USER_START_CMD;\n    EVSYS_CH0_GEN->EVCTRL.reg |= EVSYS_CH0_GEN_START_CMD;\n    #endif\n    #if defined(MW_SAMD_EVSYS_CH1)\n    EVSYS->USER.reg = EVSYS_USER_CHANNEL(2) |                                           // Attach the event user (receiver) to channel 1 (n + 1)\n        EVSYS_USER_USER(EVSYS_CH1_USER_EVENT);                            // Set the event user (receiver) as EVSYS_CH2_USER_EVENT\n    EVSYS->CHANNEL.reg = EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT |                           // No event edge detection\n        EVSYS_CHANNEL_PATH_ASYNCHRONOUS |                              // Set event path as asynchronous\n        EVSYS_CHANNEL_EVGEN(EVSYS_CH1_GEN_EVENT) |                     // Set event generator (sender) as EVSYS_CH2_GEN_EVENT\n        EVSYS_CHANNEL_CHANNEL(1);                                      // Attach the generator (sender) to channel 1\n    EVSYS_CH1_USER->EVCTRL.reg |= EVSYS_CH1_USER_START_CMD;\n    EVSYS_CH1_GEN->EVCTRL.reg |= EVSYS_CH1_GEN_START_CMD;\n    #endif\n    #if defined(MW_SAMD_EVSYS_CH2)\n    EVSYS->USER.reg = EVSYS_USER_CHANNEL(3) |                                           // Attach the event user (receiver) to channel 2 (n + 1)\n        EVSYS_USER_USER(EVSYS_CH2_USER_EVENT);                            // Set the event user (receiver) as EVSYS_CH3_USER_EVENT\n    EVSYS->CHANNEL.reg = EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT |                           // No event edge detection\n        EVSYS_CHANNEL_PATH_ASYNCHRONOUS |                              // Set event path as asynchronous\n        EVSYS_CHANNEL_EVGEN(EVSYS_CH2_GEN_EVENT) |                     // Set event generator (sender) as EVSYS_CH3_GEN_EVENT\n        EVSYS_CHANNEL_CHANNEL(2);                                      // Attach the generator (sender) to channel 2\n    EVSYS_CH2_USER->EVCTRL.reg |= EVSYS_CH2_USER_START_CMD;\n    EVSYS_CH2_GEN->EVCTRL.reg |= EVSYS_CH2_GEN_START_CMD;\n    #endif\n    #if defined(MW_SAMD_EVSYS_CH3)\n    EVSYS->USER.reg = EVSYS_USER_CHANNEL(4) |                                           // Attach the event user (receiver) to channel 3 (n + 1)\n        EVSYS_USER_USER(EVSYS_CH3_USER_EVENT);                            // Set the event user (receiver) as EVSYS_CH4_USER_EVENT\n    EVSYS->CHANNEL.reg = EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT |                           // No event edge detection\n        EVSYS_CHANNEL_PATH_ASYNCHRONOUS |                              // Set event path as asynchronous\n        EVSYS_CHANNEL_EVGEN(EVSYS_CH3_GEN_EVENT) |                     // Set event generator (sender) as EVSYS_CH4_GEN_EVENT\n        EVSYS_CHANNEL_CHANNEL(3);                                      // Attach the generator (sender) to channel 3\n    EVSYS_CH3_USER->EVCTRL.reg |= EVSYS_CH3_USER_START_CMD;\n    EVSYS_CH3_GEN->EVCTRL.reg |= EVSYS_CH3_GEN_START_CMD;\n    #endif\n    #endif\n}\n/* Function: MW_Arduino_Terminate ================================================\n* For Arduino MKR/Leonardo and its variants, the Virtual COM port is handled\n* by the controller. In case the code running on the target exits main,\n* the COM port cannot be accessed until a hard reset is performed.\n* To over come this issue, a while loop is added to make sure that\n* upon getting a stop command from external mode, the code running on\n* the target stops but the code will not exit the main.\n* This will ensure that the COM port is accessible even after the\n* external mode has been stopped. */\nvoid MW_Arduino_Terminate(void){\n    #if defined(ARDUINO_VIRTUAL_COM_PORT) || (defined(ARDUINO_ARDUINO_NANO33BLE) && (!defined(USE_MBEDRTOS)))\n    disable_rt_OneStep();\n    while(1){};     /* To continue virtual COM port functionality */\n    #endif\n}\n\n#ifdef NANO_MOTOR_CARRIER\nvoid MW_EnableNanoCarrierBatteryCharging(void) {\n    Wire.begin();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG00);\n    Wire.write(0x06); // min sys voltage 3.88V + max input current 2.0 A\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG01);\n    Wire.write(0x1B); // Charge Battery + Minimum System Voltage 3.5V\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG02);\n    Wire.write(0x00); // Charge current  512 mA\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG04);\n    Wire.write(0x9E); // Charge Voltage Limit 4.128V\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG05);\n    Wire.write(0x8A); // Enable Battery Charge termination + disable watchdog\n    Wire.endTransmission();\n}\n#endif\n\n\n// Overrun detection function for ESP32\n#if defined(ESP_PLATFORM) && defined(_RTT_OVERRUN_DIGITAL_PIN_)\nvoid onOverrunDetect(int id)\n{\n    digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, HIGH);\n}\n#endif\n// LocalWords:  AVR Bareboard ADK SPI RTT SSPIN Modbus MKR"},{"name":"MW_arduino_digitalio.cpp","type":"source","group":"legacy","path":"C:\\Users\\kzlee\\Desktop\\FRS24\\FRS24_SIMULINK\\untitled_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024a\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"#ifndef MATLAB_MEX_FILE\n#include <Arduino.h>\n#include \"MW_arduino_digitalio.h\"\n#endif\n#include \"rtwtypes.h\"\n\n// Digital I/O initialization\nextern \"C\" void digitalIOSetup(uint8_T pin, uint8_T mode) \n{ \n    #ifndef MATLAB_MEX_FILE\n    // mode = 0: Input\n    // mode = 1: Output\n    // mode = 2: Input pullup\n    if (mode==0) {\n        pinMode(pin, INPUT);\n    }\n    else if (mode==1) {\n        pinMode(pin, OUTPUT);\n    }\n    else {\n        // mode = 2 is for input pullup\n        pinMode(pin, INPUT_PULLUP);\n    }\n    #endif\n}\n\n// Write a logic value to pin\nextern \"C\" void writeDigitalPin(uint8_T pin, boolean_T val)\n{\n    #ifndef MATLAB_MEX_FILE\n    if (val) {\n        digitalWrite(pin, HIGH);\n    } \n    else {\n        digitalWrite(pin, LOW);\n    }\n    #endif\n}\n\n// Read logical state of a digital pin\nextern \"C\" boolean_T readDigitalPin(uint8_T pin)\n{\n    #ifndef MATLAB_MEX_FILE\n    boolean_T ret;\n     \n    ret = (digitalRead(pin) == HIGH) ? 1:0;\n    return ret;\n    #else\n    return (boolean_T)0;\n    #endif\n}\n"},{"name":"MW_custom_RTOS_header.h","type":"header","group":"other","path":"C:\\Users\\kzlee\\Desktop\\FRS24\\FRS24_SIMULINK\\untitled_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _MW_CUSTOM_RTOS_HEADER_H_\r\n#define _MW_CUSTOM_RTOS_HEADER_H_\r\n#define MW_BASERATE_PRIORITY           14\r\n#define MW_BASERATE_PERIOD             0.1\r\n#define MW_NUMBER_SUBRATES             0\r\n#define MW_NUMBER_APERIODIC_TASKS      0\r\n#define MW_IS_CONCURRENT               0\r\n#define MW_NUMBER_TIMER_DRIVEN_TASKS   0\r\n\r\nextern void exitFcn(int sig);\r\nextern void *terminateTask(void *arg);\r\nextern void *baseRateTask(void *arg);\r\nextern void *subrateTask(void *arg);\r\nextern mw_thread_t schedulerThread;\r\nextern mw_thread_t baseRateThread;\r\nextern mw_thread_t subRateThread[];\r\nextern SemaphoreHandle_t stopSem;\r\nextern SemaphoreHandle_t baserateTaskSem;\r\nextern SemaphoreHandle_t subrateTaskSem[];\r\nextern int taskId[];\r\nextern int subratePriority[];\r\n\r\n#endif\r\n\r\n#define MW_MAX_TASKNAME                16\r\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\kzlee\\Desktop\\FRS24\\FRS24_SIMULINK\\untitled_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"MW_ArduinoHWInit.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE ESP32-WROOM(Arduino Compatible)\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERSIZE 250\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_MAXCONTIGSAMPLES 10\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_LOGGINGBUFFERSIZE 250\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_MAXCONTIGSAMPLES 10\n#define MW_CONNECTIONINFO_XCPONSERIAL_BAUDRATE codertarget.arduinobase.registry.getBaudRate\n#define MW_CONNECTIONINFO_XCPONSERIAL_COMPORT codertarget.arduinobase.internal.getExternalModeMexArgs('Serial')\n#define MW_CONNECTIONINFO_XCPONSERIAL_VERBOSE 0\n#define MW_CONNECTIONINFO_XCPONWIFI_IPADDRESS codertarget.arduinobase.internal.getExternalModeMexArgs('Wifi')\n#define MW_CONNECTIONINFO_XCPONWIFI_PORT 17725\n#define MW_CONNECTIONINFO_XCPONWIFI_VERBOSE 0\n#define MW_EXTMODE_CONFIGURATION XCP on Serial\n#define MW_EXTMODE_COMPORTBAUD 921600\n#define MW_EXTMODE_USEREALTIMESTAMPLOGGING 0\n#define MW_RTOS FreeRTOS\n#define MW_RTOSBASERATETASKPRIORITY 14\n#define MW_DETECTTASKOVERRUNS 0.000000\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_ESP32_ESP32_BOARD -1\n#define MW_ESP32_BOOTBUTTONPRESSCHECKBOX 0\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_RUNTIME_DISABLEPARALLELBUILD 0\n#define MW_RUNTIME_FORCEBUILDSTATICLIBRARY 0\n#define MW_RUNTIME_VERBOSEOUTPUT 0\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_PORT_SOURCE 2\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_COMPORT_SPECIFY 3\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_BAUD 0\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_BAUD_SPECIFY \n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_SERIAL_PORT 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_PORT_SOURCE1 2\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_PORT_SOURCE2 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_COMPORT_SPECIFY 3\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_BAUD 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_BAUD_SPECIFY \n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_SERIAL_PORT 0\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_PORT_SOURCE1 2\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_PORT_SOURCE2 0\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_COMPORT_SPECIFY 3\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_BAUD -1\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_BAUD_SPECIFY \n#define MW_CONNECTEDIO_CONNECTEDIOMODE 0\n#define MW_CONNECTEDIO_ACTIONONOVERRUN 0\n#define MW_OVERRUNDETECTION_ENABLE_OVERRUN_DETECTION 0\n#define MW_OVERRUNDETECTION_DIGITAL_OUTPUT_TO_SET_ON_OVERRUN 13\n#define MW_ANALOGINREFVOLTAGE_ANALOG_INPUT_REFERENCE_VOLTAGE 0.000000\n#define MW_SERIAL_SERIAL0_BAUD_RATE 8\n#define MW_SERIAL_SERIAL0_BAUD_SPECIFY 921600\n#define MW_SERIAL_SERIAL0_CONFIG 3\n#define MW_SERIAL_SERIAL0_TX_PIN 1\n#define MW_SERIAL_SERIAL0_RX_PIN 3\n#define MW_SERIAL_SERIAL1_BAUD_RATE 8\n#define MW_SERIAL_SERIAL1_BAUD_SPECIFY 921600\n#define MW_SERIAL_SERIAL1_CONFIG 3\n#define MW_SERIAL_SERIAL1_TX_PIN 33\n#define MW_SERIAL_SERIAL1_RX_PIN 32\n#define MW_SERIAL_SERIAL2_BAUD_RATE 8\n#define MW_SERIAL_SERIAL2_BAUD_SPECIFY 921600\n#define MW_SERIAL_SERIAL2_CONFIG 3\n#define MW_SERIAL_SERIAL2_TX_PIN 17\n#define MW_SERIAL_SERIAL2_RX_PIN 16\n#define MW_I2C_I2C0BUSSPEEDHZ 100000\n#define MW_I2C_I2C0_SDA_PIN 21\n#define MW_I2C_I2C0_SCL_PIN 22\n#define MW_SPI_SPI0_CLOCK_OUT_FREQUENCY 1\n#define MW_SPI_SPI0_MODE 0\n#define MW_SPI_SPI0_BITORDER 0\n#define MW_SPI_SPI0_SDO_PIN 23\n#define MW_SPI_SPI0_SDI_PIN 19\n#define MW_SPI_SPI0_SCK_PIN 18\n#define MW_SPI_SDSLAVESELECT 5.000000\n#define MW_SPI_SPI1_CLOCK_OUT_FREQUENCY 1\n#define MW_SPI_SPI1_MODE 0\n#define MW_SPI_SPI1_BITORDER 0\n#define MW_SPI_SPI1_SDO_PIN 13\n#define MW_SPI_SPI1_SDI_PIN 12\n#define MW_SPI_SPI1_SCK_PIN 14\n#define MW_WIFI_WIFI_SSID yourNetwork\n#define MW_WIFI_SET_WIFI_ENCRYPTION 0\n#define MW_WIFI_WIFI_WEP_KEY D0D0DEADF00DABBADEAFBEADED\n#define MW_WIFI_WIFI_WEP_KEY_INDEX 0\n#define MW_WIFI_WIFI_WPA_PASSWORD secretPassword\n#define MW_WIFI_WIFI_WPA2_USERNAME username\n#define MW_WIFI_WIFI_WPA2_PASSWORD password\n#define MW_WIFI_IP_ADDRESS_ASSIGNMENT 0\n#define MW_WIFI_WIFI_IP_ADDRESS 192.168.1.20\n#define MW_WIFI_WIFI_DNS_SERVER_ADDRESS 192.168.1.0\n#define MW_WIFI_WIFI_GATEWAY_ADDRESS 192.168.1.0\n#define MW_WIFI_WIFI_SUBNET_MASK 255.255.255.0\n#define MW_THINGSPEAK_ENABLE_CUSTOMSERVER 48\n#define MW_THINGSPEAK_IP_ADDRESS 184.106.153.149\n#define MW_THINGSPEAK_PORT 80\n#define MW_PWM_PWM_DEFAULT_FREQUENCY 1000\n#define MW_BLE_PERIPHERAL_DEVICE_NAME Arduino\n#define MW_BLE_PERIPHERAL_LOCAL_NAME Arduino\n#define MW_BLE_ADVERTISING_INTERVAL 160\n#define MW_BLE_MIN_CONNECTION_INTERVAL 6\n#define MW_BLE_MAX_CONNECTION_INTERVAL 3200\n#define MW_MQTT_BROKERSERVICE 0\n#define MW_MQTT_BROKERADDRESS mqtt3.thingspeak.com\n#define MW_MQTT_BROKERPORT 1883\n#define MW_MQTT_USERNAME \n#define MW_MQTT_PASSWORD \n#define MW_MQTT_CLIENTID \n#define MW_HTTP_ENABLE_CUSTOM_CA_CERTIFICATE 0\n#define MW_HTTP_CUSTOM_CA_CERTIFICATE_FILE \n#define MW_IOBLOCKSMODE deployed\n#define MW_DATAVERSION 2016.02\n#define MW_DASHBOARDCODEGENINFO_ENABLECODEGEN 0\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_CODEGEN 1\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_BLOCKCLASS codertarget.targetHiddenBlkInsert.internal.circularGauge\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_REGFCN codertarget.arduinobase.blocks.registerDashboardBlk\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_VALIDATEFCN codertarget.targetHiddenBlkInsert.internal.isDashboardBlockCodegenEnabled\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_CODEGEN 1\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_BLOCKCLASS codertarget.targetHiddenBlkInsert.internal.lcdTextDisplay\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_REGFCN codertarget.arduinobase.blocks.registerDashboardBlk\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_VALIDATEFCN codertarget.targetHiddenBlkInsert.internal.isDashboardBlockCodegenEnabled\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_CODEGEN 1\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_BLOCKCLASS codertarget.targetHiddenBlkInsert.internal.pushButton\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_REGFCN codertarget.arduinobase.blocks.registerDashboardBlk\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_VALIDATEFCN codertarget.targetHiddenBlkInsert.internal.isDashboardBlockCodegenEnabled\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"io_wrappers.cpp","type":"source","group":"legacy","path":"C:\\Users\\kzlee\\Desktop\\FRS24\\FRS24_SIMULINK\\untitled_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024a\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"/*\n* Wrappers to make I/O functions available with C linkage. This allows C++\n* methods to be called from C code.\n*\n* Copyright 2011-2022 The MathWorks, Inc. */\n\n#include <inttypes.h>\n#include \"Arduino.h\"\n#include \"rtwtypes.h\"\n\n#if (defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)) || (defined(_RTT_UDP_) && (_RTT_UDP_ != 0)) || (defined(_RTT_TCP_) && (_RTT_TCP_ != 0) || defined(_RTT_THINGSPEAK_))\n#include <Ethernet.h>\n#include <EthernetUdp.h>\n#include <SPI.h>\n#endif\n\n#if defined(ARDUINO_ARM_CORTEX_M0_PLUS)\nextern \"C\" void __libc_init_array(void);\n#endif\n\nextern \"C\" {\n    void __cxa_pure_virtual(void);\n}\n\nextern \"C\" void Serial_begin(int port, long r, int c)\n{\n    static int serialInit=0;\n    #if !(defined(ESP_PLATFORM))\n    serialInit=0;   //Reset serialInit flag for all targets except ESP32\n    #endif\n    #if defined(ARDUINO_ARCH_SAM)\n    UARTClass::UARTModes config = UARTClass::UARTModes(c);\n    #else\n    int config = c;\n    #endif\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n    switch(port) {\n        case 0:\n            if(serialInit & 1)return;\n            serialInit |= 1;\n            #if defined(ESP_PLATFORM)\n            Serial.begin(r,config,_RTT_RX_PIN_SERIAL0_,_RTT_TX_PIN_SERIAL0_);\n            #elif (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial.begin(r);\n            #else\n            Serial.begin(r,config);\n            #endif\n            break;\n        case 1:\n            if(serialInit & 2)return;\n            serialInit |= 2;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n            #if defined(ESP_PLATFORM)\n            Serial1.begin(r,config,_RTT_RX_PIN_SERIAL1_,_RTT_TX_PIN_SERIAL1_);\n            #elif (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial1.begin(r);\n            #else\n            Serial1.begin(r,config);\n            #endif\n            #endif\n            break;\n        case 2:\n            if(serialInit & 4)return;\n            serialInit |= 4;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n            #if defined(ESP_PLATFORM)\n            Serial2.begin(r,config,_RTT_RX_PIN_SERIAL2_,_RTT_TX_PIN_SERIAL2_);\n            #elif (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial2.begin(r);\n            #else\n            Serial2.begin(r,config);\n            #endif\n            #endif\n            break;\n        case 3:\n            if(serialInit & 8)return;\n            serialInit |= 8;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial3.begin(r);\n            #else\n            Serial3.begin(r,config);\n            #endif\n            #endif\n\n            break;\n        case 4:\n            if(serialInit & 16)return;\n            serialInit |= 16;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 5)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial4.begin(r);\n            #else\n            Serial4.begin(r,config);\n            #endif\n            #endif\n            break;\n       case 5:\n            if(serialInit & 32)return;\n            serialInit |= 32;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 6)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial5.begin(r);\n            #else\n            Serial5.begin(r,config);\n            #endif\n            #endif\n\n            break;\n       case 6:\n            if(serialInit & 64)return;\n            serialInit |= 64;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 7)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial6.begin(r);\n            #else\n            Serial6.begin(r,config);\n            #endif\n            #endif\n\n            break;\n        case 7:\n            if(serialInit & 128)return;\n            serialInit |= 128;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 8)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial7.begin(r);\n            #else\n            Serial7.begin(r,config);\n            #endif\n            #endif\n      case 8:\n            if(serialInit & 256)return;\n            serialInit |= 256;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 9)\n            #if (defined(ARDUINO_TEENSY41))\n            Serial8.begin(r);\n            #else\n            Serial8.begin(r,config);\n            #endif\n            #endif\n\n            break;\n\n            break;\n    }\n    #else\n    if(serialInit & 1)return;\n    serialInit |= 1;\n    Serial.begin(r,SERIAL_8N1);\n    #endif\n}\n\nextern \"C\" void Serial_read(int port, int showOutStatus, uint8_t *outData, int16_t *outStatus)\n{\n    int libFcnOutput;\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n    switch(port) {\n        case 0:\n            libFcnOutput = Serial.read();\n            break;\n        case 1:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n            libFcnOutput = Serial1.read();\n            #endif\n            break;\n        case 2:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n            libFcnOutput = Serial2.read();\n            #endif\n            break;\n        case 3:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n            libFcnOutput = Serial3.read();\n            #endif\n            break;\n        case 4:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 5)\n            libFcnOutput = Serial4.read();\n            #endif\n            break;\n        case 5:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 6)\n            libFcnOutput = Serial5.read();\n            #endif\n            break;\n        case 6:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 7)\n            libFcnOutput = Serial6.read();\n            #endif\n            break;\n       case 7:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 8)\n            libFcnOutput = Serial7.read();\n            #endif\n            break;\n       case 8:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 9)\n            libFcnOutput = Serial8.read();\n            #endif\n            break;\n    }\n    #else\n    libFcnOutput = Serial.read();\n    #endif\n    *outData = (uint8_t) libFcnOutput;\n    *outStatus = (libFcnOutput != -1);\n}\n\nextern \"C\" void Serial_write(int port, uint8_t * c, size_t s)\n{\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n    switch(port) {\n        case 0:\n            Serial.write(c, s);\n            break;\n        case 1:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n            Serial1.write(c, s);\n            #endif\n            break;\n        case 2:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n            Serial2.write(c, s);\n            #endif\n            break;\n        case 3:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n            Serial3.write(c, s);\n            #endif\n            break;\n        case 4:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 5)\n            Serial4.write(c, s);\n            #endif\n            break;\n        case 5:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 6)\n            Serial5.write(c, s);\n            #endif\n            break;\n        case 6:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 7)\n            Serial6.write(c, s);\n            #endif\n            break;\n        case 7:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 8)\n            Serial7.write(c, s);\n            #endif\n            break;\n        case 8:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 9)\n            Serial8.write(c, s);\n            #endif\n            break;\n    }\n    #else\n    Serial.write(c, s);\n    #endif\n}\n\n#if _RTT_UDP_ != 0\nEthernetUDP Udp[_RTT_UDP_];\nIPAddress localIpAddress(_RTT_Local_IP1, _RTT_Local_IP2, _RTT_Local_IP3, _RTT_Local_IP4);\nbyte mac[] = { _RTT_Local_MAC1, _RTT_Local_MAC2, _RTT_Local_MAC3, _RTT_Local_MAC4, _RTT_Local_MAC5, _RTT_Local_MAC6 };\nunsigned int localport[_RTT_UDP_] = {_RTT_UDP_LOCAL_PORT_ORDERED};\nint configureSuccess;\nint trialcount=0;\nextern \"C\" uint8_t MW_EthernetAndUDPBegin(uint8_t udpindex, uint32_t localPort)\n{\n    static int only_one_ethernet_begin;\n    if (only_one_ethernet_begin==0)\n    {\n        #if (defined(_RTT_DISABLE_Ethernet_DHCP_) && (_RTT_DISABLE_Ethernet_DHCP_ !=0))\n        Ethernet.begin(mac, localIpAddress);\n        configureSuccess = 1;\n        #else\n        configureSuccess = Ethernet.begin(mac);\n        #endif\n        only_one_ethernet_begin++;\n\n        for(trialcount=0;trialcount<5;trialcount++)\n        {\n            if(Serial)\n            {\n                break;\n            }else\n            {\n                delay(1000);\n            }\n        }\n        // Depending on if the IP address assignment using DHCP has been successful or not,\n        // send the appropriate information back to the host.\n        // If External mode over TCP/IP or Wifi, do not print this Info. Information of IP address will be printed as\n        // a part of rtiostream_open\n        #if (!(defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)))\n        if (configureSuccess==1)\n        {\n            if(Ethernet.localIP()[0] == 0 || Ethernet.localIP()[0] == 255)\n            {\n                /*Tried to assign Static IP, failed due to one of the following reasons :\n                * 1. Ethernet shield is not connected properly with Arduino.\n                * 2. Ethernet shield is not connected to a network.\n                **/\n                Serial.println(\"<<<IP address: Failed to configure.>>>\");\n            }\n            else\n            {\n                // If the Configuration is successful, relay back the assigned IP address.\n                Serial.print(\"<<<IP address: \");\n                for (byte thisByte = 0; thisByte < 4; thisByte++)\n                {\n                    // Print the value of each byte of the IP address:\n                    Serial.print(Ethernet.localIP()[thisByte], DEC);\n                    if (thisByte<3)\n                    {\n                        Serial.print(\".\");\n                    }\n                }\n                Serial.println(\">>>\");\n            }\n        }\n        else\n        {\n            // If the Configuration failed,relay back the error message.\n            Serial.println(\"<<<IP address: Failed to configure.>>>\");\n        }\n        Serial.flush();\n        #endif\n    }\n    return (Udp[udpindex].begin(localport[udpindex]));\n}\n\nextern \"C\" int MW_UDPFinalWrite(uint8_t udpindex, uint8_t data, uint8_t remoteIPOctect1,uint8_t remoteIPOctect2,uint8_t remoteIPOctect3,uint8_t remoteIPOctect4, uint32_t remoteport)\n{\n    IPAddress remoteIpAddress(remoteIPOctect1,remoteIPOctect2, remoteIPOctect3, remoteIPOctect4);\n    Udp[udpindex].beginPacket(remoteIpAddress, remoteport);\n    Udp[udpindex].write(data);\n    return(Udp[udpindex].endPacket());\n}\n\nextern \"C\" void MW_UDPFinalRead(uint8_t udpindex, uint8_t *data, int32_t *outStatus)\n{\n    int packetSize = Udp[udpindex].parsePacket();\n    if(packetSize)\n    {\n        int libFcnOutput;\n        libFcnOutput = Udp[udpindex].read();\n        *data = (uint8_t) libFcnOutput;\n        *outStatus = (libFcnOutput != -1);\n    }\n\n    else\n    {\n        //When the client is not connected the status flag is accordingly toggled.\n        *outStatus = 0;\n    }\n}\n#endif\n\n#if defined(_RTT_THINGSPEAK_) || (_RTT_TCP_ != 0)\nIPAddress localIpAddress(_RTT_Local_IP1, _RTT_Local_IP2, _RTT_Local_IP3, _RTT_Local_IP4);\nbyte mac[] = { _RTT_Local_MAC1, _RTT_Local_MAC2, _RTT_Local_MAC3, _RTT_Local_MAC4, _RTT_Local_MAC5, _RTT_Local_MAC6 };\nint configureSuccess;\nint trialcount;\n#if _RTT_TCP_ != 0\nEthernetServer server[_RTT_TCP_] = {_RTT_TCP_SERVER_PORT_ORDERED};\n#endif\nextern \"C\" void MW_EthernetAndTCPServerBegin(uint8_t tcpindex, uint32_t serverport)\n{\n    static int only_one_tcp_server_and_ethernet_begin = 0;\n\n    if (only_one_tcp_server_and_ethernet_begin==0)\n    {\n        #if (defined(_RTT_DISABLE_Ethernet_DHCP_) && (_RTT_DISABLE_Ethernet_DHCP_ !=0))\n        Ethernet.begin(mac, localIpAddress);\n        configureSuccess = 1;\n        #else\n        configureSuccess = Ethernet.begin(mac);\n        #endif\n        only_one_tcp_server_and_ethernet_begin++;\n\n        for(trialcount=0;trialcount<5;trialcount++)\n        {\n            if(Serial)\n            {\n                break;\n            }else\n            {\n                delay(1000);\n            }\n        }\n\n        // Depending on if the IP address assignment using DHCP has been successful or not,\n        // send the appropriate information back to the host.\n        // If External mode over TCP/IP or Wifi, do not print this Info. Information of IP address will be printed as\n        // a part of rtiostream_open\n        #if (!(defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)))\n        if (configureSuccess==1)\n        {\n            if(Ethernet.localIP()[0] == 0 || Ethernet.localIP()[0] == 255)\n            {\n                /*Tried to assign Static IP, failed due to one of the following reasons :\n                * 1. Ethernet shield is not connected properly with Arduino.\n                * 2. Ethernet shield is not connected to a network.\n                **/\n                Serial.println(\"<<<IP address: Failed to configure.>>>\");\n            }\n            else\n            {\n                // If the Configuration is successful, relay back the assigned IP address.\n                Serial.print(\"<<<IP address: \");\n                for (byte thisByte = 0; thisByte < 4; thisByte++)\n                {\n                    // Print the value of each byte of the IP address:\n                    Serial.print(Ethernet.localIP()[thisByte], DEC);\n                    if (thisByte<3)\n                    {\n                        Serial.print(\".\");\n                    }\n                }\n                Serial.println(\">>>\");\n            }\n        }\n        else\n        {\n            // If the Configuration failed,relay back the error message.\n            Serial.println(\"<<<IP address: Failed to configure.>>>\");\n        }\n        Serial.flush();\n        #endif\n\n        #if _RTT_TCP_ != 0\n        // Begin all servers based on the number of different TCP ports.\n        for (int i = 0;i < _RTT_TCP_;i++)\n        {\n            server[i].begin();\n        }\n        #endif\n        only_one_tcp_server_and_ethernet_begin = 1;\n    }\n}\n#endif\n#if _RTT_TCP_ != 0\nextern \"C\" void MW_TCPFinalread(uint8_t tcpindex, uint8_t *data, uint32_t serverport, int32_t *outStatus)\n{\n    int libFcnOutput;\n    EthernetClient client = server[tcpindex].available();\n    if (int(client) == true) {\n        libFcnOutput = client.read();\n        *data = (uint8_t) libFcnOutput;\n        *outStatus = (libFcnOutput != -1);\n\n    }\n    else\n    {\n        //When the client is not connected the status flag is accordingly toggled.\n        *outStatus = 0;\n    }\n\n}\nextern \"C\" void MW_TCPFinalWrite(uint8_t tcpindex, uint8_t data, uint32_t serverport)\n{\n    server[tcpindex].write(data);\n}\n#endif\n\n\n#if defined(_ROTH_LEONARDO_)\nextern \"C\" void MW_usbattach()\n{\n    USBDevice.attach();\n}\n#elif defined(ARDUINO_VIRTUAL_COM_PORT)\nextern \"C\" void MW_usbattach()\n{\n    __libc_init_array();\n    USBDevice.init();\n    USBDevice.attach();\n\n}\n#endif\n\nextern \"C\" void MW_pinModeAnalogInput(uint32_t pinNumber)\n{\n    if (pinNumber < A0)\n        pinNumber += A0;\n    pinMode(pinNumber, INPUT);\n}\n\nextern \"C\" void MW_delay_in_milliseconds(uint32_T period)\n{\n    uint32_T start_time = 0;\n    start_time = millis();\n    while(millis()- start_time <= period)\n    {\n        1;\n    }\n}\n\nextern \"C\" void MW_delay_in_microseconds(uint32_T period)\n{\n    uint32_T start_time = 0;\n    start_time = micros();\n    while(micros()- start_time <= period)\n    {\n        1;\n    }\n}\n\nextern \"C\" uint32_T MW_getCurrentTime_in_milliseconds()\n{\n   return (uint32_T)millis();\n}\n\n\n// #if defined(ARDUINO_ARDUINO_NANO33BLE)\n// #include \"Arduino.h\"\n// #include \"pins_arduino.h\"\n// #include \"mbed/drivers/AnalogIn.h\"\n// #include \"mbed.h\"\n//\n// extern uint8_t nano33BLE_dutycycle[21];\n// extern uint16_t nano33BLE_period[21];\n//\n//\n// events::EventQueue queue(32 * EVENTS_EVENT_SIZE);\n// rtos::Thread t;\n// mbed::Ticker tick;\n//\n// static int write_resolution = 8;\n// static int read_resolution = 10;\n//\n// extern \"C\" void MW_NANO33BLE_analogWrite_1(pin_size_t pin, int val, uint16_t period)\n// {\n//   if (pin >= PINS_COUNT) {\n//     return;\n//   }\n//   float percent = (float)val/(float)((1 << write_resolution)-1);\n//   mbed::PwmOut* pwm = digitalPinToPwm(pin);\n//   if (pwm == NULL) {\n//     pwm = new mbed::PwmOut(digitalPinToPinName(pin));\n//     digitalPinToPwm(pin) = pwm;\n//     pwm->period_ms(period);\n//   }\n//   pwm->write(percent);\n// }\n//\n// extern \"C\" void MW_NANO33BLE_PWM_Handler()\n// {\n//     MW_NANO33BLE_analogWrite_1(5, nano33BLE_dutycycle[5], nano33BLE_period[5]);\n// }\n//\n// extern \"C\" void MW_NANO33BLE_PWM_Setup()\n// {\n//   t.start(callback(&queue, &events::EventQueue::dispatch_forever));\n//   tick.attach(queue.event(MW_NANO33BLE_PWM_Handler),_RTT_PWM_PIN5_CST );\n// }\n//\n//\n//\n//\n// extern \"C\" void MW_NANO33BLE_analogWrite(PinName pin, int val, uint16_t period)\n// {\n// //   pin_size_t idx = PinNameToIndex(pin);\n// //   if (idx != NOT_A_PIN) {\n// //     MW_NANO33BLE_analogWrite_1(idx, 50, period);\n// //   } else {\n// //     mbed::PwmOut* pwm = new mbed::PwmOut(pin);\n// //     pwm->period_ms(2);\n// //     float percent = (float)50/(float)((1 << write_resolution)-1);\n// //     pwm->write(percent);\n// //   }\n// }\n//\n// #endif\n"},{"name":"mw_freertos_init.c","type":"source","group":"legacy","path":"C:\\Users\\kzlee\\Desktop\\FRS24\\FRS24_SIMULINK\\untitled_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024a\\toolbox\\target\\shared\\freertos\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2016-2022 The MathWorks, Inc. */\n\n\n/* ---------------------------- */\n/* RTOS-specific headers        */\n/* Note: must be included first */\n/* ---------------------------- */\n#include \"mw_freertos.h\"\n\n/* ---------------------------- */\n/* Other headers                */\n/* ---------------------------- */\n#include <string.h>\n\n/* ---------------------------- */\n/* RTOS-specific declarations   */\n/* ---------------------------- */\n\n/* Other declarations */\n#define _unused(x) ((void)(x))\n\n/* Note: stdint.h is included in FreeRTOS.h\n * If stdint.h cannot be located then:\n *   + If using GCC ensure the -nostdint options is *not* being used.\n *   + Ensure the project's include path includes the directory in which your\n *     compiler stores stdint.h.\n *   + Set any compiler options necessary for it to support C99, as technically\n *     stdint.h is only mandatory with C99 (FreeRTOS does not require C99 in any\n *     other way).\n *   + The FreeRTOS download includes a simple stdint.h definition that can be\n *     used in cases where none is provided by the compiler.  The files only\n *     contains the typedefs required to build FreeRTOS.  Read the instructions\n *     in FreeRTOS/source/stdint.readme for more information.\n */\n\n/* Scheduler timer */\nmw_timer_t mw_scheduler_timer_def;\nint32_t mw_timer_id;\n\n#ifndef MW_EXTMODE_STACKSIZE\n#define MW_EXTMODE_STACKSIZE 10240\n#endif\n\n/* Scheduler task move base rate task from wait state to ready state */\nvoid schedulerTask(TimerHandle_t arg)\n{\n    _unused(arg);\n#ifdef DETECT_OVERRUNS\n    testForRateOverrun(0);\n#endif\n    /* Release base rate semaphore to move base rate task from wait state to ready state */\n    mw_osSemaphoreRelease(&baserateTaskSem);\n}\n\n/* ---------------------------- */\n/* Externally visible functions */\n/* ---------------------------- */\nvoid mw_WaitForThisEvent(int sigNo)\n{\n    _unused(sigNo);\n}\n\nvoid mw_AddBlockForThisEvent(int sigNo)\n{\n    _unused(sigNo);\n}\n\nvoid mw_AddHandlerForThisEvent(int sigNo, int sigToBlock[], int numSigToBlock, void *sigHandler)\n{\n    _unused(sigNo);\n    _unused(sigToBlock);\n    _unused(numSigToBlock);\n    _unused(sigHandler);\n}\n\nvoid mw_RestoreHandlerForThisEvent(int sigNo)\n{\n}\n\nvoid baseRateTaskWrapper(void *arg)\n{\n    baseRateTask(arg);\n}\n#ifdef MW_HAS_MULTIPLE_RATES\nvoid subrateTaskWrapper(void *arg)\n{\n    subrateTask(arg);\n}\n#endif\n\nvoid mw_RTOSInit(float baseRatePeriod, int numSubrates)\n{\n    int32_t status;\n#ifdef MW_HAS_MULTIPLE_RATES\n    int i;\n#endif\n/* MW_FREERTOS is only defined for STM32 CubeMX target. Remove the guard MW_FREERTOS after the Trace source code is shipped for STM32 CubeMX target*/  \n#if  !defined(MW_FREERTOS) && ( configUSE_TRACE_FACILITY == 1 )\n    /* Initialise the trace recorder and create the label used to post user\n     events to the trace recording on each tick interrupt. */\n    vTraceInitTraceData();\n    xTickTraceUserEvent = xTraceOpenLabel( \"tick\" );\n    /* Start the trace recording */\n    uiTraceStart();\n#endif\n    \n    /* Create semaphore for base rate task */\n    status = mw_osSemaphoreCreate(&baserateTaskSem, 0);\n    CHECK_STATUS(status, 0, \"mw_osSemaphoreCreate:baserateTaskSem\");\n    /* Create semaphore for stop task */\n    status = mw_osSemaphoreCreate(&stopSem, 0);\n    CHECK_STATUS(status, 0, \"mw_osSemaphoreCreate:stopSem\");\n    \n    /* Create baseRateTask thread */\n    baseRateThread.priority = ( MW_BASERATE_PRIORITY );\n    baseRateThread.taskhandle = NULL;\n    baseRateThread.stackdepth = getStackDepth(OS_STKSIZE);\n    strcpy(baseRateThread.name,\"Baserate\");\n    status = mw_osThreadCreate(&baseRateThread, &baseRateTaskWrapper, NULL);\n    CHECK_STATUS(status, 0, \"mw_osThreadCreate\");\n    \n#ifdef MW_HAS_MULTIPLE_RATES\n    for (i = 0; i < MW_NUMBER_SUBRATES; i++) {\n        taskId[i] = i;\n        status = mw_osSemaphoreCreate(&subrateTaskSem[i], 0);\n        CHECK_STATUS(status, 0,\"mw_osSemaphoreCreate\");\n        /* Initialize thread structure */\n        subRateThread[i].priority = MW_BASERATE_PRIORITY - (i+1);\n#ifdef MW_NEEDS_BACKGROUND_TASK\n        CHECK_STATUS(subRateThread[i].priority>(tskIDLE_PRIORITY+1), 1, \"Too many rates\");\n#else\n        CHECK_STATUS(subRateThread[i].priority>tskIDLE_PRIORITY, 1, \"Too many rates\");\n#endif\n        subRateThread[i].taskhandle = NULL;\n        subRateThread[i].stackdepth = getStackDepth(OS_STKSIZE);\n        status = mw_osThreadCreate(&subRateThread[i], &subrateTaskWrapper, (void *)&taskId[i]);\n        \n        CHECK_STATUS(status, 0, \"mw_osThreadCreate\");\n#ifdef DETECT_OVERRUNS\n        status = mw_osBinarySemaphoreCreate(&rateTaskFcnRunningMutex[i+1]);\n        CHECK_STATUS(status, 0, \"mw_osBinarySemaphoreCreate\");\n#endif\n    }\n#endif\n    \n    /* Set the SysTick priority */\n#ifdef MW_SCHEDULER_PRIORITY\n    NVIC_SetPriority((IRQn_Type)(-1), MW_SCHEDULER_PRIORITY);\n#endif\n    \n#ifdef MW_NEEDS_BACKGROUND_TASK\n    /* Create backgroundTask thread */\n    backgroundThread.priority = tskIDLE_PRIORITY;\n    backgroundThread.taskhandle = NULL;\n    backgroundThread.stackdepth = getStackDepth(MW_EXTMODE_STACKSIZE);\n    strcpy(backgroundThread.name,\"Background\");\n    status = mw_osThreadCreate(&backgroundThread, backgroundTask, NULL);\n    CHECK_STATUS(status, 0 ,\"mw_osThreadCreate\");\n#endif\n#ifdef DETECT_OVERRUNS\n    status = mw_osBinarySemaphoreCreate(&rateTaskFcnRunningMutex[0]);\n    CHECK_STATUS(status, 0, \"mw_osBinarySemaphoreCreate\");\n#endif    \n\n#ifdef MW_STANDALONE_EXECUTION_PROFILER_ON\n    status = mw_osBinarySemaphoreCreate(&profilingDataStoreMutex);\n    CHECK_STATUS(status, 0, \"mw_osBinarySemaphoreCreate\");\n#endif\n    \n    /* Create timer to call scheduler task */\n    mw_timer_id = 0;\n    mw_scheduler_timer_def.handle = NULL;\n    mw_scheduler_timer_def.period = (TickType_t)(baseRatePeriod*1000/portTICK_PERIOD_MS);\n    mw_scheduler_timer_def.autoreload = pdTRUE;\n    mw_scheduler_timer_def.id = (void *)mw_timer_id;\n    strcpy(mw_scheduler_timer_def.name, \"Timer1\");\n    status = mw_osTimerCreate(&mw_scheduler_timer_def, &schedulerTask);\n    CHECK_STATUS(status, 0,\"mw_osTimerCreate\");\n    /* Start the timer */\n    status = mw_osTimerStart(&mw_scheduler_timer_def, (TickType_t )1000);\n    CHECK_STATUS(status, 0,\"mw_osTimerCreate\");\n    /* Start the real time scheduler */\n    #ifndef MW_DONOTSTART_SCHEDULER\n    vTaskStartScheduler();\n    #endif\n}\n"},{"name":"mw_semaphore.c","type":"source","group":"legacy","path":"C:\\Users\\kzlee\\Desktop\\FRS24\\FRS24_SIMULINK\\untitled_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024a\\toolbox\\target\\shared\\freertos\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2016 The MathWorks, Inc. */\n#include \"mw_semaphore.h\"\n\n/* Create and Initialize a Semaphore object used for managing resources. */\nint  mw_osSemaphoreCreate \t(mw_semaphore_t * semaphore_def, int32_t count)\n{\n    *semaphore_def = xSemaphoreCreateCounting( SEMAPHORE_MAX_COUNT, count);\n    if (semaphore_def!=NULL)\n        return 0;\n    else\n        return 1;\n}\n/* Wait until a Semaphore token becomes available. */\nint  mw_osSemaphoreWait \t(mw_semaphore_t * semaphore_def, uint32_t millisec)\n{\n    if (semaphore_def==NULL || *semaphore_def==NULL)\n        return 1;\n    else\n        return (xSemaphoreTake(*semaphore_def, millisec)!=pdTRUE);\n}\n/* Wait until a Semaphore token becomes available. */\nint  mw_osSemaphoreWaitEver\t(mw_semaphore_t * semaphore_def)\n{\n    if (semaphore_def==NULL || *semaphore_def==NULL)\n        return 1;\n    else\n        return (xSemaphoreTake(*semaphore_def, portMAX_DELAY)!=pdTRUE);\n}\n/* Release a Semaphore token. */\nint mw_osSemaphoreRelease  (mw_semaphore_t * semaphore_def)\n{\n    if (semaphore_def==NULL || *semaphore_def==NULL)\n        return 1;\n    else\n        return (xSemaphoreGive(*semaphore_def)!=pdTRUE);\n}\n/* Delete a Semaphore that was created by osSemaphoreCreate. */\nint mw_osSemaphoreDelete \t(mw_semaphore_t * semaphore_def)\n{\n    if (semaphore_def!=NULL)\n    {\n        vSemaphoreDelete(*semaphore_def);\n        return 0;\n    }\n    else\n    {\n        return 1;\n    }\n}\n\n/* The functions below contain the definitions for the binary semaphore */\n/* Create and Initialize a Binary Semaphore  object used for managing resources. */\nint  mw_osBinarySemaphoreCreate \t(mw_semaphore_t * semaphore_def)\n{\n    *semaphore_def = xSemaphoreCreateBinary();\n    if (semaphore_def!=NULL)\n    {\n        /* The semaphore can now be used. Its handle is stored in the\n        semaphore_def variable.  Calling xSemaphoreTake() on the semaphore here\n        will fail until the semaphore has first been given. */\n        return mw_osSemaphoreRelease (semaphore_def);\n    }\n    else\n    { \n        /* There was insufficient OpenRTOS heap available for the semaphore to\n        be created successfully. */\n        return 1;\n    }\n}\n\n/* Try Wait to check if the Binary Semaphore token is available. */\nint  mw_osBinarySemaphoreTryLock\t(mw_semaphore_t * semaphore_def)\n{\n    if (semaphore_def==NULL || *semaphore_def==NULL)\n    {\n        return 1;\n    }\n    else\n    {\n        /* See if we can obtain the semaphore.  If the semaphore is not\n        available do not wait. Non-blocking with 0 ticks */\n        return (xSemaphoreTake(*semaphore_def, ( TickType_t ) 0)!=pdTRUE);\n    }\n}\n"},{"name":"mw_thread.c","type":"source","group":"legacy","path":"C:\\Users\\kzlee\\Desktop\\FRS24\\FRS24_SIMULINK\\untitled_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024a\\toolbox\\target\\shared\\freertos\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2016 The MathWorks, Inc. */\n#include \"mw_thread.h\"\n\n#define _unused(x) ((void)(x))\n\n/*------------------------------------------------------------------------------------------------------*/\n/*------------------------------------- Thread functions -----------------------------------------------*/\n/*------------------------------------------------------------------------------------------------------*/\n/* Create a thread and add it to Active Threads and set it to state READY. */\nint mw_osThreadCreate(mw_thread_t * aThread, TaskFunction_t aTaskFunction, void *aFcnParamter)\n{\n\tif( aThread==NULL )\n    {\n        return 1;\n    }\n    else\n    {\n        BaseType_t out = xTaskCreate(aTaskFunction, aThread->name, aThread->stackdepth, aFcnParamter, aThread->priority, &(aThread->taskhandle));\t\n        configASSERT( aThread->taskhandle );\n        return (out!=pdPASS);\n    }\n}\n\n/* Return the thread handle of the current running thread.  */\nTaskHandle_t mw_osThreadGetId   (void)\n{\n#if ( INCLUDE_xTaskGetCurrentTaskHandle == 1 )\n\treturn xTaskGetCurrentTaskHandle();\n#else\n    return NULL;\n#endif\n}\n\n/* Terminate execution of a thread and remove it from Active Threads. */\nvoid   mw_osThreadTerminate \t(mw_thread_t * thread_def)\n{\n\tif (thread_def!=NULL)\n    {\n        vTaskDelete(thread_def->taskhandle);\n    }\n}\n\n/* Change priority of an active thread. */\nvoid  mw_osThreadSetPriority \t(mw_thread_t * thread_def, UBaseType_t  priority)\n{\n\tif (thread_def!=NULL)\n    {\n        vTaskPrioritySet(thread_def->taskhandle, priority);\n        thread_def->priority = priority;\n    }\n}\n\n/* Get current priority of an active thread. */\nUBaseType_t mw_osThreadGetPriority \t(mw_thread_t * thread_def)\n{\n#if INCLUDE_vTaskPriorityGet==1\n    if (thread_def!=NULL)\n    {\n        return uxTaskPriorityGet(thread_def->taskhandle);\n    }\n    else\n    {\n        return thread_def->priority;\n    }\n#else\n    return thread_def->priority;\n#endif\n}\n\n/* Pass control to next thread that is in state READY. */\nvoid   mw_osThreadYield \t\t(void)\n{\n\ttaskYIELD();\n}\n\nvoid   mw_osThreadExit \t(void * value_ptr)\n{\n    _unused(value_ptr);\n#if INCLUDE_vTaskDelete /* vTaskDelete() enabled */\n      vTaskDelete(NULL);\n#endif\n}\n\nint   mw_osThreadJoin \t(mw_thread_t thread_def, void ** value_ptr)\n{\n    _unused(value_ptr);\n    _unused(thread_def);\n#if INCLUDE_vTaskDelete /* vTaskDelete() enabled */\n      vTaskDelete(thread_def.taskhandle);\n      return 0;\n#else\n      return 1; /* vTaskDelete() not available */\n#endif\n}\n\nvoid   mw_osThreadSleep \t(const long msToDelay )\n{\n\tvTaskDelay( (TickType_t) msToDelay/portTICK_PERIOD_MS );\n}\n"},{"name":"mw_timer.c","type":"source","group":"legacy","path":"C:\\Users\\kzlee\\Desktop\\FRS24\\FRS24_SIMULINK\\untitled_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024a\\toolbox\\target\\shared\\freertos\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2016 The MathWorks, Inc. */\n#include \"mw_timer.h\"\n\n/*------------------------------------------------------------------------------------------------------*/\n/*----------------------------- Timer Wrapper functions ------------------------------------------------*/\n/*------------------------------------------------------------------------------------------------------*/\nint mw_osTimerCreate(mw_timer_t * timer_def, TimerCallbackFunction_t funcptr)\n{\n    timer_def->handle = xTimerCreate(timer_def->name, timer_def->period, timer_def->autoreload, timer_def->id, funcptr);\n    if (timer_def->handle != NULL)\n    {\n        return 0;\n    }\n    else \n    {\n        return 1;\n    }\n}\n\nint mw_osTimerStart(mw_timer_t * timer_def, TickType_t xBlockTime )\n{\n\tif (timer_def!=NULL && timer_def->handle!=NULL)\n    {\n        return (xTimerStart(timer_def->handle, xBlockTime)!=pdPASS);\n    }\n    else\n    {\n        return 1;\n    }\n}\n\nint mw_osTimerStop(mw_timer_t * timer_def)\n{\n\tif (timer_def!=NULL && timer_def->handle!=NULL)\n    {\n        return (xTimerStop(timer_def->handle, 500000)!=pdPASS);\n    }\n    else\n    {\n        return 1;\n    }\n}\n\nint mw_osTimerDelete(mw_timer_t * timer_def)\n{\n\tif (timer_def!=NULL && timer_def->handle!=NULL)\n    {\n        return (xTimerDelete(timer_def->handle, 500000)!=pdPASS);\n    }\n    else\n    {\n        return 1;\n    }\n}\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};